<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>有种🌹少年是MayDay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="有种🌹少年是MayDay">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="有种🌹少年是MayDay">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ColvTzzi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="有种🌹少年是MayDay" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有种🌹少年是MayDay</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-实习俩月再看cola" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/14/%E5%AE%9E%E4%B9%A0%E4%BF%A9%E6%9C%88%E5%86%8D%E7%9C%8Bcola/" class="article-date">
  <time class="dt-published" datetime="2021-12-14T11:29:58.000Z" itemprop="datePublished">2021-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/14/%E5%AE%9E%E4%B9%A0%E4%BF%A9%E6%9C%88%E5%86%8D%E7%9C%8Bcola/">实习俩月再看cola</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://zivlnoff.github.io/graph/image-20211214220816058.png"></p>
<h3 id="知识总是在不断膨胀，最终都会浓缩成精华"><a href="#知识总是在不断膨胀，最终都会浓缩成精华" class="headerlink" title="知识总是在不断膨胀，最终都会浓缩成精华"></a>知识总是在不断膨胀，最终都会浓缩成精华</h3><p>​    在我们的应用中，如果处处都reasonable，那可能就是现实生活的“田园”了吧。尽管我们没法去把这一切一字排开，但其中的内涵，确实值得咀嚼。至少方法总比问题多，不是吗</p>
<ul>
<li><p>可扩展性差？-&gt;扩展点（一种嵌入框架或者称为注入的多维策略工厂）</p>
</li>
<li><p>面向过程？-&gt;SOLID原则、设计模式、UML图、领域建模(Eric Evans的《领域驱动设计》)。</p>
</li>
<li><p>分层不合理？ -&gt;分离<strong>必要</strong>关注点</p>
</li>
<li><p>随心所欲？ -&gt;规范+CR</p>
</li>
</ul>
<p>​    我只能告诉你，当你够强，你施展的空间比天大</p>
<p>​    SOLID原则是基石，是你的武器，玩过DNF吗，武器是可以打磨的，单一职责原则(SRP)，开闭原则(OCP)，里氏替换原则(LSP)，接口隔离原则(ISP)和依赖倒置原则(DIP)，给你了，看你怎么使用。抽象能力，设计模式，架构模式，UML，以及阅读优秀框架源码是你很好的朋友。</p>
<p>​    应该都比我很熟悉领域建模吧，我也就开发了没几个月，感觉也有味了</p>
<ul>
<li>思想和方法论（这是人生</li>
<li>贫血和充血模式（依赖团队水平</li>
</ul>
<p>​    分层设计都有所耳闻，相信吧，设计模式和领域设计能很好的帮你去根据业务场景去设计。</p>
<p>​    规范设计是真的很有诱惑，放对位置、贴好标签、类名约定、方法名约定、错误码约定（系统异常和业务异常）、测试约定，这依旧取决团队水平。</p>
<p>​    来看看cola呗~</p>
<p>​    cola1.0相当炫酷，这个起步我jio得很不错</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220805478.png"></p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214203203905.png"></p>
<p>​    cola2.0，这个突破很大了，增加了更加明确的定义和重要的依赖倒置设计原则，结构清晰带来了很好的可理解性和可维护性</p>
<p><strong>新架构分层</strong>：Domain层不再直接依赖Infrastructure层。<br><strong>新组件划分</strong>：对组件进行了重新定义和划分，加了新组件，去除了一些老组件（Validator，Convertor等）。<br><strong>新扩展点设计</strong>：引入了新概念，让扩展更加灵活。<br><strong>新二方库定位</strong>：二方库不仅仅是DTO，也是Domain Model的轻量级表达和实现。</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220753934.png"></p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220745457.png"></p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220723498.png"></p>
<ol>
<li><strong>二方库里的组件</strong><ul>
<li>api：存放的是应用对外的接口。</li>
<li>dto.domainmodel：用来做数据传输的轻量级领域对象。</li>
<li>dto.domainevent: 用来做数据传输的领域事件。</li>
</ul>
</li>
<li><strong>Application里的组件</strong><ul>
<li>service：接口实现的facade，没有业务逻辑，可以包含对不同终端的adapter。</li>
<li>eventhandler：处理领域事件，包括本域的和外域的。</li>
<li>executor：用来处理命令（Command）和查询（Query），对复杂业务，可以包含<a target="_blank" rel="noopener" href="https://ata.alibaba-inc.com/articles/147540?spm=ata.25287382.0.0.6bee7536AJrV8H">Phase和Step</a>。</li>
<li>interceptor: COLA提供的对所有请求的AOP处理机制。</li>
</ul>
</li>
<li><strong>Domain里的组件</strong><ul>
<li>domain：领域实体，允许继承domainmodel。</li>
<li>domainservice: 领域服务，用来提供更粗粒度的领域能力。</li>
<li>gateway：对外依赖的网关接口，包括存储、RPC、Search等。</li>
</ul>
</li>
<li><strong>Infrastructure里的组件</strong><ul>
<li>config：配置信息相关。</li>
<li>message：消息处理相关。</li>
<li>repository：存储相关，是gateway的特化，主要用来做本域的数据CRUD操作。</li>
<li>gateway：对外依赖的网关接口（Domain里的gateway）的实现。</li>
</ul>
</li>
</ol>
<p>​    依赖视图就是介个样子：</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220711990.png"></p>
<p>​    调用视图</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220702450.png"></p>
<p>​    cola3.0它进化了！</p>
<p>摘录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">##### 设计中的弯弯绕</span><br><span class="line"></span><br><span class="line">**深入考察一下，我们系统中，类似于“地心说”这样的弯弯绕的设计，实在是不在少数**。</span><br><span class="line"></span><br><span class="line">**从系统架构的角度看**，有些弯弯绕是因为系统边界划分不合理，导致职责不清，依赖混乱。</span><br><span class="line"></span><br><span class="line">**从应用架构的角度看**，有些弯弯绕是因为过度设计，为了追求所谓的灵活性和可扩展性，使用了不恰当的设计。导致本来可以直观呈现的代码逻辑，被各种包装，各种隐藏，各种转发.... 无形中极大的阻碍了代码的可读性和可理解性，增加了维护成本。</span><br><span class="line"></span><br><span class="line">举个例子，**我看过无数的业务系统，喜欢拿业务流程编排说事情。因此，在业务系统中，可以看到各种五花八门的“弯弯绕设计”。**</span><br><span class="line"></span><br><span class="line">触发这次升级的动机，主要是因为，自己在实践COLA的过程中，的确发现有些华而不实的功能。在COLA作为阿里云的基础应用架构，其影响力越来越大的时候，我有责任给到大家一个正确的引导——**去伪存真，简洁有效，而不是引入更多的复杂度**。</span><br><span class="line"></span><br><span class="line">实际上，COLA是有两部分组成的：</span><br><span class="line"></span><br><span class="line">**一方面COLA是一种架构思想**，是整合了洋葱圈架构、适配器架构、DDD、整洁架构、TMF等架构思想的一种应用架构。</span><br><span class="line"></span><br><span class="line">**另一方面COLA也是框架组件**，通过这次升级，我使用奥卡姆剃刀砍掉了绝大部分的组件能力，仅仅保留了扩展点功能。其用意是不希望COLA作为框架给到应用开发者太多的约束，这不符合简单有效的风格。</span><br><span class="line"></span><br><span class="line">**奥卡姆精神**</span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>​    cola4.0升华了</p>
<p>​    什么是应用架构的本质，它这样定义架构，架构的本质，简单来说，就是<strong>要素结构</strong>。</p>
<p>​    所谓的<strong>要素（Components）是指架构中的主要元素，结构是指要素之间的相互关系（Relationship）</strong>。<br><img src="https://zivlnoff.github.io/graph/image-20211214220653468.png"></p>
<ul>
<li>组织架构：其要素是什么？组成组织的要素当然是人，结构呢？结构是人与人之间的关系。因此，组织架构就是关于定义人的职责划分，以及人与人之间协作关系的一种设计方法。</li>
<li>应用架构：<strong>代码是其核心组成要素，结构就是这些代码该如何被组织</strong>，也就是要如何处理模块（Module）、组件（Component）、包（Package）和类（Class）之间的关系。简而言之，<strong>应用架构就是要解决代码要如何被组织的问题。</strong></li>
</ul>
<p>​    一个没有架构的应用系统，就像一堆随意堆放、杂乱无章的玩具，只有熵值，没有熵减。而一个有良好架构的应用系统，有章法、有结构，一切都显得井井有条。<br><img src="https://zivlnoff.github.io/graph/image-20211214220636733.png"></p>
<ul>
<li><p>好的组织架构</p>
<ul>
<li>会遵循一定的架构模式，大部分的组织都会按职能和业务来设计自己的架构。如果你反其道而行之，硬要把销售、财务和技术人员放在一个部门，就会显得很奇怪。</li>
</ul>
</li>
<li><p>好的应用架构</p>
<ul>
<li>遵循一些共同模式，不管是六边形架构、洋葱圈架构、整洁架构、还是COLA架构，<strong>都提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度</strong>。</li>
</ul>
</li>
</ul>
<p>​    应用架构的本质，就是要从繁杂的业务系统中提炼出共性，找到解决业务问题的最佳共同模式，为开发人员提供统一的认知，治理混乱。帮助应用系统“从混乱到有序”，<strong>COLA架构就是为此而生，其核心职责就是定义良好的应用结构，提供最佳实践</strong>。</p>
<p>​    例如，典型的业务系统都需要：</p>
<ul>
<li>接收request，响应response；</li>
<li>做业务逻辑处理，像校验参数，状态流转，业务计算等等；</li>
<li>和外部系统有联动，像数据库，微服务，搜索引擎等；</li>
</ul>
<p>​    正是有这样的共性存在，才会有很多普适的架构思想出现，比如分层架构、六边形架构、洋葱圈架构、整洁架构（Clean Architecture）、DDD架构等等。    </p>
<p>​    对于一个典型的业务应用系统来说，COLA会做如下层次定义，每一层都有明确的职责定义：</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220617858.png"></p>
<p>1）适配层（Adapter Layer）：负责对前端展示（web，wireless，wap）的路由和适配，对于传统B/S系统而言，adapter就相当于MVC中的controller；</p>
<p>2）应用层（Application Layer）：主要负责获取输入，组装上下文，参数校验，调用领域层做业务处理，如果需要的话，发送消息通知等。层次是开放的，应用层也可以绕过领域层，直接访问基础实施层；</p>
<p>3）领域层（Domain Layer）：主要是封装了核心业务逻辑，并通过领域服务（Domain Service）和领域对象（Domain Entity）的方法对App层提供业务实体和业务逻辑计算。领域是应用的核心，不依赖任何其他层次；</p>
<p>4）基础实施层（Infrastructure Layer）：主要负责技术细节问题的处理，比如数据库的CRUD、搜索引擎、文件系统、分布式服务的RPC等。此外，领域防腐的重任也落在这里，外部依赖需要通过gateway的转义处理，才能被上面的App层和Domain层使用。</p>
<p>​    分层是属于大粒度的职责划分，太粗，我们有必要往下再down一层，细化到包结构的粒度，才能更好的指导我们的工作。</p>
<p>​    还是拿一堆玩具举例子，分层类似于拿来了一个架子，分包类似于在每一层架子上又放置了多个收纳盒。<strong>所谓的内聚，就是把功能类似的玩具放在一个盒子里，这样可以让应用结构清晰，极大的降低系统的认知成本和维护成本</strong>。<br><img src="https://zivlnoff.github.io/graph/image-20211214220609419.png"></p>
<p>​    那么，对于一个后端应用来说，应该需要哪些收纳盒呢？这一块的设计真可谓是费了老鼻子劲了，基本上每一次COLA的迭代都会涉及到包结构的调整，迭代到现在，才算基本稳定下来。<br><img src="https://zivlnoff.github.io/graph/image-20211214220601108.png"></p>
<p>各个包结构的简要功能描述，如下表所示：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>包名</th>
<th>功能</th>
<th>必选</th>
</tr>
</thead>
<tbody><tr>
<td>Adapter层</td>
<td>web</td>
<td>处理页面请求的Controller</td>
<td>否</td>
</tr>
<tr>
<td>Adapter层</td>
<td>wireless</td>
<td>处理无线端的适配</td>
<td>否</td>
</tr>
<tr>
<td>Adapter层</td>
<td>wap</td>
<td>处理wap端的适配</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>App层</td>
<td>executor</td>
<td>处理request，包括command和query</td>
<td>是</td>
</tr>
<tr>
<td>App层</td>
<td>consumer</td>
<td>处理外部message</td>
<td>否</td>
</tr>
<tr>
<td>App层</td>
<td>scheduler</td>
<td>处理定时任务</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Domain层</td>
<td>model</td>
<td>领域模型</td>
<td>否</td>
</tr>
<tr>
<td>Domain层</td>
<td>ability</td>
<td>领域能力，包括DomainService</td>
<td>否</td>
</tr>
<tr>
<td>Domain层</td>
<td>gateway</td>
<td>领域网关，解耦利器</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Infra层</td>
<td>gatewayimpl</td>
<td>网关实现</td>
<td>是</td>
</tr>
<tr>
<td>Infra层</td>
<td>mapper</td>
<td>ibatis数据库映射</td>
<td>否</td>
</tr>
<tr>
<td>Infra层</td>
<td>config</td>
<td>配置信息</td>
<td>否</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Client SDK</td>
<td>api</td>
<td>服务对外透出的API</td>
<td>是</td>
</tr>
<tr>
<td>Client SDK</td>
<td>dto</td>
<td>服务对外的DTO</td>
<td>是</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>​    这点很重要，应该👂🏻进作者的良言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为什么Domain的model是可选的？因为COLA是应用架构，不是DDD架构。在工作中，很多同学问我领域模型要怎么设计，**我的回答通常是：无有必要勿增实体**。领域模型对设计能力要求很高，没把握用好，一个错误的抽象还不如不抽象，宁可不要用，也不要滥用，不要为了DDD而DDD。</span><br><span class="line"></span><br><span class="line">问题的关键是要看，新增的模型没有给你带来收益。比如**有没有帮助系统解耦，有没有提升业务语义表达能力的提升，有没有提升系统的可维护性和可测性等等。**</span><br><span class="line"></span><br><span class="line">模型虽然可选，但DDD的思想是一定要去学习和贯彻的，特别是统一语言、边界上下文、防腐层的思想，值得深入学习，仔细体会。实际上，COLA里面的很多设计思想都来自于DDD。其中就包括**领域包的设计**。</span><br></pre></td></tr></table></figure>

<p>​    前面的包定义，都是功能维度的定义。为了兼顾领域维度的内聚性，我们有必要对包结构进行一下微调，即顶层包结构应该是按照领域划分，让领域内聚。</p>
<p>​    也就是说，我们要综合考虑功能和领域两个维度包结构定义。按照领域和功能两个维度分包策略，最后呈现出来的，是如下图所示的顶层包节点是领域名称，领域之下，再按功能划分包结构。<br><img src="https://zivlnoff.github.io/graph/image-20211214220549484.png"></p>
<p>例如，在我们刚刚上线的一个云店铺（cloudstore）项目中，按照COLA的分包策略，我们在每一个module下面首先按照领域做一个顶层划分，然后在领域内，再按照功能进行分包。<br><img src="https://zivlnoff.github.io/graph/image-20211214220540738.png"></p>
<p>​    “高内聚，低耦合”这句话，你工作的越久，就越会觉得其有道理。</p>
<p>​    <strong>所谓耦合就是联系的紧密程度，只要有依赖就会有耦合，不管是进程内的依赖，还是跨进程的RPC依赖，都会产生耦合</strong>。依赖不可消除，同样，耦合也不可避免。我们所能做的不是消除耦合，而是把耦合降低到可以接受的程度。在软件设计中，有大量的设计模式，设计原则都是为了解耦这一目的。</p>
<p>​    在DDD中有一个很棒的解耦设计思想——防腐层（Anti-Corruption），简单说，就是应用不要直接依赖外域的信息，要把外域的信息转换成自己领域上下文（Context）的实体再去使用，从而实现本域和外部依赖的解耦。</p>
<p>​    在COLA中，我们把AC这个概念进行了泛化，将数据库、搜索引擎等数据存储都列为外部依赖的范畴。<strong>利用依赖倒置，统一使用gateway来实现业务领域和外部依赖的解耦</strong>。</p>
<p>​    其实现方式如下图所示，主要是在Domain层定义Gateway接口，然后在Infrastructure提供Gateway接口的实现。<br><img src="https://zivlnoff.github.io/graph/image-20211214220430164.png"></p>
<p>举个例子，假如有一个电商系统，对于下单这个操作，它需要联动订单服务、商品服务、库存服务、营销服务等多个系统才能完成。</p>
<p>那么在订单域，该如何获取商品和库存信息呢？最直接的方式，无外乎就是RPC调用商品和库存服务，拿到DTO直接使用就完了。</p>
<p>然而，商品域吐出的是一个大而全的DTO（可能包含几十个字段），而在下单这个阶段，订单所需要的可能只是其中几个字段而已。更合适的做法，应该是在订单域中，使用gateway对商品域和库存域的依赖进行解耦。<br><img src="https://zivlnoff.github.io/graph/image-20211214220305848.png"></p>
<p>​    这样做有两个好处，一个是降低了对外域信息依赖的耦合；另一个是通过上下文映射（Context mapping），确保本领域边界上下文（Bounded context）下领域知识的完整性，实现了统一语言（Ubiquitous language）。</p>
<p>​    然后，cola全副武装的威力绽放了</p>
<ul>
<li><p>COLA架构：关注应用架构的定义和构建，提升应用质量。</p>
</li>
<li><p>COLA组件：提供应用开发所需要的可复用组件，提升研发效率。</p>
</li>
</ul>
<p><img src="https://zivlnoff.github.io/graph/image-20211214220118040.png"></p>
<p>​    我觉得能把以下理解好，就能理解计算机中很重要的一个概念，所以我把它毫无保留的摘抄了下来————任何难以直接实现的目的，都可以通过一层抽象去完成。</p>
<h1 id="摘录："><a href="#摘录：" class="headerlink" title="摘录："></a>摘录：</h1><h4 id="新二方库定位"><a href="#新二方库定位" class="headerlink" title="新二方库定位"></a>新二方库定位</h4><p>关于二方库的定位表面上来看，是一个简单问题，<strong>因为服务的二方库无外乎就是用来暴露接口和传递数据的（DTO）。不过，往深层次思考，它并不是一个简单的问题，因为它涉及到不同界限上下文（Bounded Context）之间的协作问题。</strong> 它是分布式环境下，不同服务（SOA，RPC，微服务，叫法不同，本质一样）之间如何协作的重要架构设计问题。</p>
<h5 id="Bounded-Context之间的协作"><a href="#Bounded-Context之间的协作" class="headerlink" title="Bounded Context之间的协作"></a>Bounded Context之间的协作</h5><p>如何实现不同域之间的协作，同时又要保证各自领域的概念的完整性是有一套方法论的。总体来说，大概有两种方式：共享内核（Shared Kernel）和防腐层（ACL，Anti-Corruption Layer）。</p>
<p><strong>1. 共享内核（Shared Kernel）</strong></p>
<blockquote>
<p>It’s possible that only one of the teams will maintain the code, build, and test for what is shared. A Shared Kernel is often very difficult to conceive in the first place, and difficult to maintain, because you must have open communication between teams and constant agreement on what constitutes the model to be shared.</p>
</blockquote>
<p><img src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/3740e7f2625e6930c06f1216c5e1fbcb.png?Expires=1639488763&OSSAccessKeyId=5brTYsCF9kNTYdU5&Signature=MzRFK0h9aWuTfvDC8/JwvVCBi20=" alt="image.png"></p>
<p>上面是引用《DDD Distilled》（作者是Vaughn Vernon）关于Shared Kernel描述的原话，其优点是Share（减少重复建设），其缺点也是Share（团队之间紧耦合）。</p>
<p><strong>2. 防腐层（ACL，Anti-Corruption Layer）</strong></p>
<blockquote>
<p>An Anticorruption Layer is the most defensive Context Mapping relationship, where the downstream team creates a translation layer between its Ubiquitous Language (model) and the Ubiquitous Language (model) that is upstream to it.</p>
</blockquote>
<p><img src="https://ata2-img.oss-cn-zhangjiakou.aliyuncs.com/54c7fc014328569f02483ffcb3d87f2a.png?Expires=1639488763&OSSAccessKeyId=5brTYsCF9kNTYdU5&Signature=N8djdlzCYLekAJZgp1OaqTH+iEA=" alt="image.png"></p>
<p>同样是来自于《DDD Distilled》, 防腐层是隔离最彻底的做法，其优点是没有Share（完全解耦，各自独立），其缺点也是没有Share（有一定的转换成本）。</p>
<p><strong>不过我和Vernon的观点差不多，都比较赞成防腐层的做法。因为增加的语义转换陈本，相较于系统的可维护性和可理解性而言，是完全值得的。</strong></p>
<blockquote>
<p>Whenever possible, you should try to create an Anticorruption Layer between your downstream model and an upstream integration model, so that you can produce model concepts on your side of the integration that specifically fit your business needs and that keep you completely isolated from foreign concepts.</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/14/%E5%AE%9E%E4%B9%A0%E4%BF%A9%E6%9C%88%E5%86%8D%E7%9C%8Bcola/" data-id="ckx66m5dj0000bgm4bajkedjd" data-title="实习俩月再看cola" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mac安装qemu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/12/03/mac%E5%AE%89%E8%A3%85qemu/" class="article-date">
  <time class="dt-published" datetime="2021-12-03T15:20:36.000Z" itemprop="datePublished">2021-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/12/03/mac%E5%AE%89%E8%A3%85qemu/">mac安装qemu</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>安装xcode    输入命令     xcode-select –install</p>
</li>
<li><p>下载patched version of qemu： git clone <a target="_blank" rel="noopener" href="https://github.com/mit-pdos/6.828-qemu.git">https://github.com/mit-pdos/6.828-qemu.git</a> qemu</p>
</li>
<li><p>配置源代码：./configure –disable-kvm –disable-werror –disable-sdl –prefix=/Users/alsc/Desktop/ –target-list=”i386-softmmu x86_64-softmmu” </p>
</li>
</ol>
<ul>
<li><p>ERROR: pkg-config binary ‘pkg-config’ not found  </p>
</li>
<li><p>命令行安装pkg-config：brew install pkg-config</p>
</li>
<li><p>查看pkg-config环境配置路径：pkg-config –variable pc_path pkg-config</p>
<ul>
<li>输出 /usr/local/lib/pkgconfig:/usr/local/share/pkgconfig:/usr/lib/pkgconfig:/usr/local/Homebrew/Library/Homebrew/os/mac/pkgconfig/11.0</li>
</ul>
</li>
</ul>
<ol start="4">
<li>安装完pkg-config后运行   ./configure –disable-kvm –disable-werror –disable-sdl –prefix=/Users/alsc/Desktop/ –target-list=”i386-softmmu x86_64-softmmu”</li>
</ol>
<ul>
<li><p>ERROR: glib-2.12 gthread-2.0 is required to compile QEMU</p>
<ul>
<li><p>命令行安装 pkg-config –libs glib-2.12</p>
<ul>
<li><p>Package glib-2.12 was not found in the pkg-config search path.</p>
<p>Perhaps you should add the directory containing `glib-2.12.pc’</p>
<p>to the PKG_CONFIG_PATH environment variable</p>
<p>No package ‘glib-2.12’ found</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>命令行安装 brew install glib</li>
</ul>
<ol start="5">
<li>安装完glib后运行    ./configure –disable-kvm –disable-werror –disable-sdl –prefix=/Users/alsc/Desktop/ –target-list=”i386-softmmu x86_64-softmmu”</li>
</ol>
<ul>
<li><p>ERROR: pixman &gt;= 0.21.8 not present. Your options:</p>
<p>​     (1) Preferred: Install the pixman devel package (any recent</p>
<p>​       distro should have packages as Xorg needs pixman too).</p>
<p>​     (2) Fetch the pixman submodule, using:</p>
<p>​       git submodule update –init pixman</p>
<ul>
<li>命令行安装 brew install pixman</li>
</ul>
</li>
</ul>
<ol start="6">
<li>安装完pixman后运行      ./configure –disable-kvm –disable-werror –disable-sdl –prefix=/Users/alsc/Desktop/ –target-list=”i386-softmmu x86_64-softmmu”</li>
</ol>
<ul>
<li><p>成功输出</p>
<ul>
<li><p>ld: unknown option: –verbose</p>
<p>Install prefix  /Users/alsc/Desktop/</p>
<p>BIOS directory  /Users/alsc/Desktop//share/qemu</p>
<p>…</p>
<p>CFLAGS      -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 -I/usr/local/Cellar/glib/2.70.1/include -I/usr/local/Cellar/glib/2.70.1/include/glib-2.0 -I/usr/local/Cellar/glib/2.70.1/lib/glib-2.0/include -I/usr/local/opt/gettext/include -I/usr/local/Cellar/pcre/8.45/include -g </p>
<p>QEMU_CFLAGS    -I/usr/local/Cellar/pixman/0.40.0/include/pixman-1 -m64 -DOS_OBJECT_USE_OBJC=0 -arch x86_64 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -Wstrict-prototypes -Wredundant-decls -Wall -Wundef -Wwrite-strings -Wmissing-prototypes -fno-strict-aliasing -fno-common -Wno-string-plus-int -Wno-initializer-overrides -Wendif-labels -Wmissing-include-dirs -Wempty-body -Wnested-externs -Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers -Wold-style-definition -Wtype-limits -fstack-protector-strong </p>
<p>LDFLAGS      -m64 -framework CoreFoundation -framework IOKit -arch x86_64 -g </p>
<p>make       make</p>
<p>install      install</p>
<p>python      python -B</p>
<p>smbd       /usr/sbin/smbd</p>
<p>module support  no</p>
<p>host CPU     x86_64</p>
<p>…</p>
</li>
</ul>
</li>
</ul>
<ol start="7">
<li><p>make &amp;&amp; make install</p>
</li>
<li><p>PATH=${PATH}:/usr/local/opt/gettext/bin make install</p>
</li>
<li><p>下载Clion</p>
</li>
<li><p>进入lab1目录  命令行输入 make</p>
</li>
</ol>
<ul>
<li><p>Error: Couldn’t find an i386-<em>-elf version of GCC/binutils.<br>*** Is the directory with i386-jos-elf-gcc in your PATH?<br>*** If your i386-</em>-elf toolchain is installed with a command<br>*** prefix other than ‘i386-jos-elf-‘, set your GCCPREFIX<br>*** environment variable to that prefix and run ‘make’ again.<br>*** To turn off this error, run ‘gmake GCCPREFIX= …’.</p>
<hr>
<hr>
<p>*** Error: Couldn’t find a working QEMU executable.<br>*** Is the directory containing the qemu binary in your PATH<br>*** or have you tried setting the QEMU variable in conf/env.mk?</p>
<hr>
<p>clang: error: unsupported option ‘-gstabs’<br>clang: error: unknown argument: ‘-fno-tree-ch’</p>
<ul>
<li>as kern/entry.S<br>clang: error: unsupported option ‘-gstabs’<br>clang: error: unsupported option ‘-gstabs’<br>clang: error: unknown argument: ‘-fno-tree-ch’<br>make: *** [obj/kern/entry.o] Error 1</li>
</ul>
</li>
</ul>
<ol start="11">
<li>安装RISC-V toolchain    是否有必要？<ol>
<li><a target="_blank" rel="noopener" href="https://zhayujie.com/mit6828-env.html">https://zhayujie.com/mit6828-env.html</a></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/03/mac%E5%AE%89%E8%A3%85qemu/" data-id="ckwqjbosy0000fnm44smm4xys" data-title="mac安装qemu" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-受了文档的痛" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/28/%E5%8F%97%E4%BA%86%E6%96%87%E6%A1%A3%E7%9A%84%E7%97%9B/" class="article-date">
  <time class="dt-published" datetime="2021-11-28T10:46:57.000Z" itemprop="datePublished">2021-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/28/%E5%8F%97%E4%BA%86%E6%96%87%E6%A1%A3%E7%9A%84%E7%97%9B/">受了文档的痛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>​    相比于技术的理解、学习、使用、进而转化为能力的提升这些自身能控制并能直接体会的到的“食粮”，学习业务逻辑未免过于痛苦了。不得不思考一个问题，写代码会把“这是写给人看的”贴在脑门上进而追求逻辑清晰、良好注释、高内聚、架构设计、领域设计等等，项目技术方案是不是也应该“让新人能看懂呢？”</p>
<p>​    一个项目文档应该有什么，我自己也做得不好，虽然接触时间很短，但我知道这种难受不会是短暂的，不想每个人进来都被折磨一阵子才稍微顺手点，或者就是要去思考交流成本的问题了，因为交流的顺畅是这行业项目发展到一定高度最重要的东西了在我看来。</p>
<p>​    我觉得但凡是学习，都得有个入口吧，应该是项目系统架构、业务架构、我们的项目注重什么、为什么要弄这个项目、也就是尽可能的“大”。这一点不难，每个团队都可以做到，当然，及时更新和简洁清晰也不是那么容易的。</p>
<p>​    然后就是领域概念，这个我认为DDD提供的方法是合理的，这里应该允许有“新的”概念，但一定要充分解释并放在一块，其实也是把文档内聚了。</p>
<p>​    进而区分业务和技术方案，从业务可以留个到技术方案的跳转链接，而且业务按时间顺序从新到旧，及时更新，并注明已经过期的业务，不要让别人浪费时间去看一个“已经成仁”的业务！</p>
<p>​    技术方案就是画图画图！！加上简洁的解释！！让人知道你在干嘛，为什么这样干。</p>
<p>​    我也不喜欢看鼠标滑不到底的技术方案，不是因为怕看的多，而是怕看完之后去想，我这是看了个啥？我串不通！我自己也写的非常繁琐（不要把除了技术之外的东西放到这个篮子里）至于测试之类的东西，也开个目录好的嘛。</p>
<p>​    为了帮助新人更快成为项目中“守规矩”的一员，请大佬们把代码中、中间件的使用中、配置中用到的神技都拿出来，而且是符合一个宗旨的，比如关注性能和设计很重要，又比如统一用什么打日志，统一架构层，统一语法（虽然这很难）。</p>
<p>​    请不要没想清楚就开一个目录，不要让人点进去了带着失望而归，嗯就这个箭头“&lt;-”~~。</p>
<p>​    请把所有“有用”的东西留下，请按类别分类，合理跳转，细节用时间排序，让人带着这个是干嘛的想法进，带着好简单，原来是这样的想法舒适的走出你的领地。</p>
<p>​    一个项目的完善是很不容易的，至少在开发人员、测试人员、业务方能力达到一致性就没那么简单，但只要勤勤恳恳的、字字斟酌的，写出来的文档那就是让人想多看几眼下面的署名！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/28/%E5%8F%97%E4%BA%86%E6%96%87%E6%A1%A3%E7%9A%84%E7%97%9B/" data-id="ckwj4de6r0001gum47ezzc5g3" data-title="受了文档的痛" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Raft的理念就是放大直觉效益" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/28/Raft%E7%9A%84%E7%90%86%E5%BF%B5%E5%B0%B1%E6%98%AF%E6%94%BE%E5%A4%A7%E7%9B%B4%E8%A7%89%E6%95%88%E7%9B%8A/" class="article-date">
  <time class="dt-published" datetime="2021-11-28T10:35:01.000Z" itemprop="datePublished">2021-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/28/Raft%E7%9A%84%E7%90%86%E5%BF%B5%E5%B0%B1%E6%98%AF%E6%94%BE%E5%A4%A7%E7%9B%B4%E8%A7%89%E6%95%88%E7%9B%8A/">Raft的理念就是放大直觉效益</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="为什么要学习Raft"><a href="#为什么要学习Raft" class="headerlink" title="为什么要学习Raft"></a>为什么要学习Raft</h1><p>​    起初，就是好奇分布式关系数据库怎么去实现一致性的，觉得这是一件复杂的事，吃饭跑步也会想，去看了下paxos，但因事耽误了。后面看了《Redis设计与实现》，其中Election就提到了Raft算法，然后才去了解Raft。学习本身就是DFS的过程。至于为什么学Raft，我想有以下几点：</p>
<ol>
<li>更深的去理解一致性的概念。</li>
<li>将维度或者说是视角从单体到分布式，遇到的问题需要直视。</li>
<li>Raft有很多值得学习的看问题的角度，如哲学角度。</li>
</ol>
<p>只有热爱，知识才能发挥超越本身的价值。</p>
<h1 id="Raft—Wiki"><a href="#Raft—Wiki" class="headerlink" title="Raft—Wiki"></a>Raft—Wiki</h1><p>​    <strong>Raft</strong> is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consensus_(computer_science)">consensus</a> algorithm designed as an alternative to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a> family of algorithms. It was meant to be more understandable than Paxos by means of separation of logic, but it is also formally proven safe and offers some additional features.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Raft_(algorithm)#cite_note-paper-1">1]</a> Raft offers a generic way to distribute a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Finite-state_machine">state machine</a> across a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_cluster">cluster</a> of computing systems, ensuring that each node in the cluster agrees upon the same series of state transitions. It has a number of open-source reference implementations, with full-specification implementations in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go_(programming_language)">Go</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C%2B%2B">C++</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>, and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala</a>.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Raft_(algorithm)#cite_note-website-2">2]</a> It is named after Reliable, Replicated, Redundant, And Fault-Tolerant.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Raft_(algorithm)#cite_note-3">3]</a></p>
<p>Raft is not a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Byzantine_fault">Byzantine fault</a> tolerant algorithm: the nodes trust the elected leader.[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Raft_(algorithm)#cite_note-paper-1">1]</a></p>
<p>​    Raft是一种共识（一致性）算法，设计用于替代Paxos算法家族。通过逻辑分离的方式，它被认为比Paxos更容易理解，但它也被正式证明是安全的，并提供了一些额外的features。Raft提供了一种在计算系统集群中分发状态机的通用方法，确保集群中的每个节点都满足相同的状态转换系列。Raft不是拜占庭容错算法。</p>
<h1 id="传统请求应答"><a href="#传统请求应答" class="headerlink" title="传统请求应答"></a>传统请求应答</h1><h2 id="主从同步复制"><a href="#主从同步复制" class="headerlink" title="主从同步复制"></a>主从同步复制</h2><p><img src="https://zivlnoff.github.io/graph/image-20211202144006663.png"></p>
<p>​    客户端发送写请求，只有当主副本的数据成功同步到所有的从副本，才向客户端返回请求成功，可用性差，强一致性。</p>
<h2 id="主从异步复制"><a href="#主从异步复制" class="headerlink" title="主从异步复制"></a>主从异步复制</h2><p><img src="https://zivlnoff.github.io/graph/image-20211202144102607.png"></p>
<p>​    客户端发送写请求，主副本成功即可返回请求成功，后台另起线程异步将数据同步到从副本，可用性好。一致性分析：</p>
<ul>
<li>如果主副本无故障，最终一致性</li>
<li>如果主副本在返回请求成功之后宕机，数据不一致，</li>
</ul>
<h1 id="Raft请求应答TimeLine"><a href="#Raft请求应答TimeLine" class="headerlink" title="Raft请求应答TimeLine"></a>Raft请求应答TimeLine</h1><p><img src="https://zivlnoff.github.io/graph/image-20211202142531637.png"></p>
<p>​    Raft通过选举Leader，使其全权负责Client请求、管理Replicated log、决定何时满足安全的将log entries应用到状态机，来保证高可用性和最终一致性。</p>
<h1 id="Raft如何防止知识溢出"><a href="#Raft如何防止知识溢出" class="headerlink" title="Raft如何防止知识溢出"></a>Raft如何防止知识溢出</h1><p>​    Raft将一致性问题分解成3个各自独立的子问题：1. Election。 2. Log Replication。3. Safety。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Election"><a href="#Election" class="headerlink" title="Election"></a>Election</h1><h2 id="初态"><a href="#初态" class="headerlink" title="初态"></a>初态</h2><p><img src="https://zivlnoff.github.io/graph/image-20211202150819811.png"></p>
<ul>
<li><p>term：任期，单调递增。</p>
</li>
<li><p>Follower：从副本。</p>
</li>
<li><p>Election Timeout：选举超时时间。</p>
</li>
</ul>
<p>​        各服务器启动后，将自身状态设置为Follower，term = 0，设置Election Timeout（150ms — 300ms），Timeout时间最小的Follower会将term自增，并将自身状态置为Candidate，开始自荐。</p>
<h2 id="候选人自荐"><a href="#候选人自荐" class="headerlink" title="候选人自荐"></a>候选人自荐</h2><p><img src="https://zivlnoff.github.io/graph/image-20211202152755353.png"></p>
<ul>
<li>Candidate：候选人。</li>
<li>Request RPC：候选人自荐RPC调用。</li>
<li>votedFor：当前任期的票投给了谁。（一个term，只能投给一个人）</li>
</ul>
<p>​    自身votedFor投给自己，发送Request RPC调用，Follower收到Request RPC调用，，做以下检查：</p>
<ul>
<li><p>Candadate term &gt;= 自身term</p>
</li>
<li><p>自身votedFor为null</p>
</li>
<li><p>Candidate的log至少和自身一样新。</p>
</li>
</ul>
<p>​    满足则将term更新并将票投出。当Candidate收到大多数（包括自身）票数，自荐成功，修改自身状态为Leader。</p>
<h2 id="做主"><a href="#做主" class="headerlink" title="做主"></a>做主</h2><p><img src="https://zivlnoff.github.io/graph/image-20211202160638970.png"></p>
<ul>
<li><p>Leader：主。</p>
</li>
<li><p>AppendEntries RPC：</p>
<ul>
<li>如果没有需要replication的log，作为heartBeat延续Leader任期以防止不必要的新一轮选举。</li>
<li>如果有新的log entries，则同步复制。</li>
</ul>
</li>
<li><p>command：状态机的执行命令。</p>
</li>
<li><p>log[]：log entries；每个entry保存了状态机的command以及Leader自身term或者非Leader收到该命令时AppendEntries RPC的任期。</p>
</li>
<li><p>commitIndex：可以安全应用到状态机的highest index。log entries被视为commited态只要当前Leader的最新entry成功replicated到majority Servers。（下文细讲）</p>
</li>
<li><p>lastApplied：已应用到状态机的highest log index。</p>
</li>
</ul>
<p>​     Leader通过HeartBeat（不带log entry的AppendEntries RPC）来维护自己的地位。当收到client消息的时候，更新自身log[]，通过并行发送AppendEntries RPC同步log。</p>
<h1 id="Log-Replication"><a href="#Log-Replication" class="headerlink" title="Log Replication"></a>Log Replication</h1><p>​    选举成功后，开始服务客户端请求。Leader接收请求，将command写入log[]，并行发送AppendEntries RPC给其他Servers，一旦收到大多数Success（这时该log entry就处于commited态），Leader设置新的commitIndex，apply到自身状态机，向client返回请求结果，随后的AppendEntries会告诉Follower安全的commit信息，同时apply到状态机。</p>
<h2 id="正常case"><a href="#正常case" class="headerlink" title="正常case"></a>正常case</h2><p><img src="https://zivlnoff.github.io/graph/image-20211202171334445.png"></p>
<p>​    此状态明确了一个概念：在大多数Server写入同一个log entry时，该log entry在上帝视角就是commited态。</p>
<h2 id="极端case"><a href="#极端case" class="headerlink" title="极端case"></a>极端case</h2><p>​    当发生Leader宕机，可能出现log不一致：</p>
<ul>
<li>Follower可能miss在Leader上存在的Entries</li>
<li>Follower可能存在Leader上没有的entries。    </li>
</ul>
<p><img src="https://zivlnoff.github.io/graph/image-20211202173159955.png"></p>
<p>​    当term=8时，Leader处于最上层状态时，a-f是可能出现的follower场景。一种可能的TimeLine：</p>
<p><img src="https://zivlnoff.github.io/graph/1638439372443.gif"></p>
<h1 id="深入Committed"><a href="#深入Committed" class="headerlink" title="深入Committed"></a>深入Committed</h1><p>​    假设当Entry存在于Majority服务器即可被commit，会出现下图所示情况，导致状态机执行序列不一致。</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211202193330353.png"></p>
<p>​    当服务器达到（c）状态时，Leader为S1，接收到新的请求后通过AppendEntries RPC将index=2处的log entry同步复制到S3，此时index=2处的Entry已经存在于3个服务器&gt;5/2，如果此时commit并apply到状态机，且S1宕机，S5恢复后因为其log比S2、S3、S4新，所以可以选举成功且将Entries同步到其他服务器，这个时候只有S1、S2、S3执行了entry2的命令，且之后被overwrite，产生了数据不一致。</p>
<h2 id="Committing-entries-from-previous-terms"><a href="#Committing-entries-from-previous-terms" class="headerlink" title="Committing entries from previous terms"></a>Committing entries from previous terms</h2><p>​    为了解决上面的情况，Raft不会通过计算replicas去commit任何之前的terms对应的日志。只有当log entries term等于当前Leader的term时才通过计算replicas来判断commit。只要新的entry被commit，旧log都会被间接提交。    </p>
<h1 id="集群成员改变"><a href="#集群成员改变" class="headerlink" title="集群成员改变"></a>集群成员改变</h1><p>​    到目前为止，我们所讨论的Cluster中的服务器个数是固定的。在实际工程中，如果我们在需要变更服务器台数的时候，重启重新配置的话，会有一段时间集群处于不可用状态，为了能够动态的增加、减少、置换机器，Raft采用了two-phase方案。如果不增加extra算法直接转换可能出现的case：</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211202202913057.png"></p>
<p>​    直接从Cold转变为Cnew会导致同时出现两个Leader，因为对于Cold，2is majority，而对于Cnew，3is majority， 5可同时满足2和3的sum，所以两个Leader是完全有可能的！</p>
<p>​    因此在Raft算法中，集群先转换为一种joint consensus态，一旦此状态commit，系统就会转变为新的配置。Join consensus结合了old和new两种配置，即Cold,new。</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211202204306533.png"></p>
<p>参考文献：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Serach of an Understandable Consensus Algorithm</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/28/Raft%E7%9A%84%E7%90%86%E5%BF%B5%E5%B0%B1%E6%98%AF%E6%94%BE%E5%A4%A7%E7%9B%B4%E8%A7%89%E6%95%88%E7%9B%8A/" data-id="ckwj4de6k0000gum4990ifd5v" data-title="Raft的理念就是放大直觉效益" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-分布式事务-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-md/" class="article-date">
  <time class="dt-published" datetime="2021-11-26T15:06:03.000Z" itemprop="datePublished">2021-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-md/">分布式事务.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>​    客官请移步到这 <a target="_blank" rel="noopener" href="https://zivlnoff.github.io/">数据库事务</a></p>
<h1 id="分布式事务（使用场景？"><a href="#分布式事务（使用场景？" class="headerlink" title="分布式事务（使用场景？"></a>分布式事务（使用场景？</h1><p>​    随着互联网的飞速发展，单节点瓶颈、无容灾、负载能力低、难以维护、无法灵活扩展的单体架构在规模庞大的工程里已无力回天，当然这也促成了分布式计算、分布式存储、分布式服务登上大荧幕。而在企业中，最令人头疼的就是怎么让分布式存储不出错性能又好，那就需要对分布式事务有极其敏锐的认识。</p>
<p>​    在分布式场景下除了保证事务的ACID性质，还需要尽可能的满足CAP，即C(一致性)、A(可用性)、P(分区容忍性)的要求，一般情况下，我们简单的实现会是这样：有一个调停者(Mediator)去管理多个协同者（Colleague），以达到一致性的要求。调停者类似老师接收到学校的通知，下达到每一个同学，保证学生都能接收到学校的通知。</p>
<p>​    基于此出现了调停者模式:</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211127154524244.png"></p>
<ul>
<li><p><strong>Mediator抽象中介者角色</strong><br> 抽象中介者角色定义统一的接口，用于各同事角色之间的通信。</p>
</li>
<li><p><strong>ConcreteMediator具体中介者角色</strong><br> 具体中介者角色通过协调各同事实现协作行为，因此它必须依赖于各个具体同事角色。</p>
</li>
<li><p><strong>Colleague同事角色</strong><br> 每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。</p>
</li>
<li><p><strong>ConcreateColleague具体同事角色</strong></p>
<p>具体同事角色有自己operation，这个operation可以有两种：</p>
<ul>
<li><strong>第一种</strong>是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种方法叫做自发行为（Self-Method),与其他的同事类或中介者没有任何的依赖</li>
<li><strong>第二种</strong>是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method</li>
</ul>
<p>调停者模式可以去除个个协同者之间的依赖链，扩展以及替换都会更加灵活。分布式事务的DTP模型也是基于此被定义：</p>
</li>
</ul>
<h2 id="DTP模型"><a href="#DTP模型" class="headerlink" title="DTP模型"></a>DTP模型</h2><p>​    X/Open DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是了定义了规范和API接口，由厂商进行具体的实现。</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211127162937537.png"></p>
<p>​    X/Open DTP 定义了三个组件： AP，TM，RM</p>
<ul>
<li><p>AP(Application Program)：也就是应用程序，可以理解为使用DTP的程序</p>
</li>
<li><p>RM(Resource Manager)：资源管理器，这里可以理解为一个DBMS系统，或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制。资源必须实现XA定义的接口</p>
</li>
<li><p>TM(Transaction Manager)：事务管理器，负责协调和管理事务，提供给AP应用程序编程接口（TX协议）以及管理资源管理器</p>
<p>其中，AP 可以和TM 以及 RM 通信，TM 和 RM 互相之间可以通信，DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信，例如:TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。AP和RM之间则通过RM提供的Native API 进行资源控制，这个没有进行约API和规范，各个厂商自己实现自己的资源控制，比如Oracle自己的数据库驱动程序。</p>
</li>
<li><p>TX协议：AP对不同TM的通用协议</p>
</li>
<li><p>XA 是X/Open DTP定义的资源管理器和事务管理器之间的接口规范，TM用它来通知和协调相关RM事务的开始、结束、提交或回滚。目前Oracle、Mysql、DB2都提供了对XA的支持。XA接口是双向的系统接口，在事务管理器(TM）以及多个资源管理器之间形成通信的桥梁（XA不能自动提交）</p>
</li>
</ul>
<p><img src="https://zivlnoff.github.io/graph/image-20211127164436819.png"></p>
<p>​        下面基于DTP模型，讨论2PC。</p>
<h2 id="2PC—二阶段提交"><a href="#2PC—二阶段提交" class="headerlink" title="2PC—二阶段提交"></a>2PC—二阶段提交</h2><p>​    在XA协议的规范下，要求RM需提供prepare、commit、rollback能力，诞生第一个分布式事务解决方案——二阶段提交。</p>
<ul>
<li>第一阶段（使用XA协议的prepare）：<ul>
<li>TM询问所有RM是否同意提交，如果第一阶段所有RM同意提交，则进入第二阶段；否则放弃整体事务过程</li>
</ul>
</li>
<li>第二阶段（使用XA协议的commit/rollback）：<ul>
<li>TM通知所有RM进行提交，如RM提交错误则反馈TM，TM通知所有RM进行rollback</li>
</ul>
</li>
</ul>
<p><img src="https://zivlnoff.github.io/graph/image-20211127165151237.png"></p>
<p>​    2PC的ACID、CAP分析：</p>
<ul>
<li>A：原子性由RM自身提供的原子性保证，对于一般的关系数据库好说，但对于NoSql、RPC之类的就不太现实。</li>
<li>I：隔离性由对收到agree之后的第二阶段对资源的全局锁定来保证，但对性能有影响。</li>
<li>D：持久性由RM自身提供的持久性保证。</li>
<li>A：因为必须收到所有voter的投票，才能执行进行最终的commit/abort，就会出现RM中部分失效时，必须等到所有RM恢复才可以往前推，所以选择了强一致性，丢弃了可用性。（<strong>单点故障</strong>）<ul>
<li>而在第二阶段的执行中，如果有一个RM没法正常进行，整个资源就会无法释放（<strong>同步阻塞</strong>）。</li>
</ul>
</li>
<li>P：必须要满足，难不成RM只有一个部署？</li>
</ul>
<p>​    2PC真的满足了强一致性吗？</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>分析</th>
</tr>
</thead>
<tbody><tr>
<td>第一阶段发送vote之后coordinator挂了，参与者没挂</td>
<td>1. 参与者均agree，在coordinator恢复或重新选举新的coordinator后，重新commit，不会出现不一致。2. 参与者存在至少一个disagree，在coordinator恢复后，会收到disagree，前推abort，不会出现不一致；或者在重新选举后，检查到有disagree回答的存在，前推abort，不会出现不一致。</td>
</tr>
<tr>
<td>第一阶段发送vote之后，coordinator没挂，参与者挂了</td>
<td>1. 参与者无法恢复，相当于少了一个参与者，不会出现不一致。2. 参与者恢复，按原规则前推，不会出现不一致。</td>
</tr>
<tr>
<td>第二阶段发送commit或abort之后，coordinator挂了，参与者没挂</td>
<td>只要发送了commit或者abort，如果coordinator没法恢复，重新选举后，不会出现不一致；如果恢复了，正常前推。</td>
</tr>
<tr>
<td>第二阶段发送commit或abort之后，coordinator没挂，参与者挂了</td>
<td>1. 参与者无法恢复，相当于少了一个参与者，不会出现不一致。2. 参与者可恢复，恢复前一直阻塞，恢复后按原规则commit或abort，不会出现不一致。</td>
</tr>
<tr>
<td><strong>第二阶段发送comimt或abort之后，coordinator挂了，唯一接收到coordinator消息的参与者也挂了</strong></td>
<td><strong>这种情况下，如果要让剩下的参与者负起原来的责任，就必须按照上一个coordinator进行的操作继续下去，但我们无法知道上一个coordinator执行的是commit还是abort，也就不知道那个收到消息后挂了的参与者commit还是abort了。因此，无论我们对剩下的参与者执行commit或者abort，如果挂了的参与者恢复了，就可能造成这段时间的数据不一致！</strong></td>
</tr>
</tbody></table>
<p>​    极端情况图示：</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211128154749943.png">    </p>
<h2 id="3PC—三阶段提交"><a href="#3PC—三阶段提交" class="headerlink" title="3PC—三阶段提交"></a>3PC—三阶段提交</h2><p>​    为了解决二阶段提交出现的极端情况导致的数据不一致，出现了3PC的解决方案。通过加入precomit阶段与超时机制来解决二阶段中的极端情况，如果在第二阶段结束coordinator发送commit或者abort之后和收到的参与者一起挂了，重新选举后可以通过precommit阶段的决策来判断是comit还是abort，因为一旦进入第二阶段，推进的决策已经产生并且一致(只能说大概率是这样)。</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211128160503866.png"></p>
<p>​    但由于网络分区的存在，如果第二阶段coordinator发送了commit，voter2回答abort，voter3由于网络分区的缘故，超时自动commit，则只有voter1和voter2进行了abort，而voter3进行了commit，就产生了数据不一致的情况！</p>
<h3 id="通过聚会去理解2PC和3PC"><a href="#通过聚会去理解2PC和3PC" class="headerlink" title="通过聚会去理解2PC和3PC:"></a>通过聚会去理解2PC和3PC:</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">计划举办整个聚会的人——主办人</span><br><span class="line">计划邀请来参加聚会的人——参与人</span><br><span class="line"><span class="number">2</span>PC场景：</span><br><span class="line">主办人询问每一个参与人来不来参加聚会，如果都答应了，主办人就会通知每个人什么时候来，可能有人晚到，但一定会到！但如果有人没答应，而且聚会取消的消息只通知到了部分参与者（其中包括没答应的人），而且这些参与者和主办人都联系不到，那剩下同意来的参与者就不知道到底来不来了！来了，有人可以通知到了但是来不了，不一致！（数据不一致）</span><br><span class="line"><span class="number">3</span>PC场景：</span><br><span class="line">主办人询问每一个参与人来不来参加聚会，如果都答应了，传递给所有参与人聚会一定会进行的消息（如果在这之前有人不来，大家都会等待，不会做出任何决定，就不会不一致）。但是如果有人突然来不了了，而且另外的人主办方之后没来的及通知临时取消(网络分区)，就依旧会出现有人来有人没来的情况（数据不一致）。但是通过第一阶段的恢复有理由相信大概率大家会来，因为机器不像人那么容易反悔！</span><br></pre></td></tr></table></figure>

<h3 id="3PC-gt-2PC"><a href="#3PC-gt-2PC" class="headerlink" title="3PC&gt;2PC?"></a>3PC&gt;2PC?</h3><p>相对于2PC，3PC主要解决了协调者宕机之后事务阻塞的问题，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<p>我们可以看到，在分布式场景下，数据一致性是一个令人头疼的问题，有了网络分区（P），丢弃A保证不了C(二阶段提交)，有了A保证不了C(三阶段提交)，能否同时保证CAP吗，已经有人给出了答案。</p>
<h2 id="分布式场景下的CAP定理"><a href="#分布式场景下的CAP定理" class="headerlink" title="分布式场景下的CAP定理"></a>分布式场景下的CAP定理</h2><p><img src="https://zivlnoff.github.io/graph/image-20211127122359135.png"></p>
<p>​    <strong>分布式场景下CAP最多只能满足其二</strong></p>
<p>​    而在多数分布式场景下， P是是必不可少的，所以在CA中的权衡就成了关键。而在面向用户的应用中，用户的体验感也即系统响应时间至关重要，所以我们很难抛弃掉A，但一致性就无法保证。因此，弱化一致性的概念，定义一种新的衡量CA的维度，就有了BASE标准：</p>
<ul>
<li><strong>基本可用（Basically Available）</strong></li>
<li><strong>软状态（ Soft State）</strong></li>
<li><strong>最终一致性（ Eventual Consistency）</strong></li>
</ul>
<p>下图客官多多体会(此文不谈)：</p>
<p><img src="https://zivlnoff.github.io/graph/image-20211127123322241.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>​    Raft算法 <a target="_blank" rel="noopener" href="https://zivlnoff.github.io/2021/11/28/Raft%E7%9A%84%E7%90%86%E5%BF%B5%E5%B0%B1%E6%98%AF%E6%94%BE%E5%A4%A7%E7%9B%B4%E8%A7%89%E6%95%88%E7%9B%8A/">Raft的理念就是放大直觉效益</a></p>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a target="_blank" rel="noopener" href="https://ata.alibaba-inc.com/articles/166757?spm=ata.25287382.0.0.25781e39DnAeog">https://ata.alibaba-inc.com/articles/166757?spm=ata.25287382.0.0.25781e39DnAeog</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-md/" data-id="ckwgl13wq0000v6m47j7nhbjf" data-title="分布式事务.md" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/12/14/%E5%AE%9E%E4%B9%A0%E4%BF%A9%E6%9C%88%E5%86%8D%E7%9C%8Bcola/">实习俩月再看cola</a>
          </li>
        
          <li>
            <a href="/2021/12/03/mac%E5%AE%89%E8%A3%85qemu/">mac安装qemu</a>
          </li>
        
          <li>
            <a href="/2021/11/28/%E5%8F%97%E4%BA%86%E6%96%87%E6%A1%A3%E7%9A%84%E7%97%9B/">受了文档的痛</a>
          </li>
        
          <li>
            <a href="/2021/11/28/Raft%E7%9A%84%E7%90%86%E5%BF%B5%E5%B0%B1%E6%98%AF%E6%94%BE%E5%A4%A7%E7%9B%B4%E8%A7%89%E6%95%88%E7%9B%8A/">Raft的理念就是放大直觉效益</a>
          </li>
        
          <li>
            <a href="/2021/11/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-md/">分布式事务.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 ColvTzzi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>